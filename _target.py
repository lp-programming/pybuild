import pathlib
import subprocess
class glob:
    def __init__(self, p, g):
        self.path = p
        self.glob = g

class proc:
    def __init__(self, *args):
        self.args = args

class func:
    def __init__(self, f):
        self.func = f

class target(dict):
    common_args = []
    modes = dict(
        debug = [],
        release = []
    )
    precompile_args = [
        "--precompile",
        "-c"
    ]

    build = pathlib.Path("build/")
    prefix = pathlib.Path("/usr/local/")

    module_lines = [
        "// Autogenerated by pybuild",
        "// do not edit!",
        "// Any additions can be made through pybuild's target.module_lines",
        "// then regenerate"
    ]
    
    module_maps = ["modules.map"]
    pymodules = []

    project = pathlib.Path(".")
    
    _name = None
    @property
    def name(self):
        return self.get("name", self._name)
    @name.setter
    def name(self, val):
        self._name = val
    
    @property
    def requirements(self):
        return self.get("requirements", [])
    @property
    def virtual(self):
        return self.get("virtual", False)
    @property
    def source(self):
        yield __file__
        from . import build
        yield build.__file__
        import targets
        yield targets.__file__
        for m in self.pymodules:
            yield m.__file__
        yield from self.module_maps
        yield from self.get("source", [])
    @property
    def deps(self):
        for i in self.get('deps', []):
            yield i
    @property
    def targets(self):
        return self.get("targets", [])
    def getArgs(self, mode="debug"):
        if 'function' in self:
            yield self['function']
            return
        if 'cmd' in self:
            yield from self.cmd
            return
        if self.virtual:
            yield "true"
            return
        for i in self.common_args:
            yield from self.expand(i)
        for i in self.modes[mode]:
            yield from self.expand(i)
        for i in self.get("args"):
            yield from self.expand(i)
    @property
    def cmd(self):
        for i in self.get("cmd", []):
            yield from self.expand(i)
    def expand(self, i):
        if isinstance(i, glob):
            for p in pathlib.Path(i.path).glob(i.glob):
                yield str(p)
        elif isinstance(i, func):
            for f in i.func():
                if not isinstance(f, str):
                    raise RuntimeError("Tried to get args from a faulty requirement function")
                yield f
        elif isinstance(i, proc):
            p = subprocess.run(i.args, stdout = subprocess.PIPE, stdin = subprocess.PIPE)
            for o in p.stdout.decode('utf-8').split():
                o = o.strip()
                if o:
                    yield o
        else:
            yield i

cppms = {}

system_headers = set()
local_headers = set()

def scan_file(f, module_name):
    deps = []
    
    for line in f.readlines():
        match line.strip().split():
            case "export", "module", n:
                module_name = n.rstrip(';')
            case ("export", "import", n) | ("import", n):
                match n.strip():
                    case header if n.startswith('<') and n.endswith('>;'):
                        system_headers.add(header[1:-2])
                    case header if n.startswith('"') and n.endswith('";'):
                        local_headers.add(header[1:-2])
                    case header:
                        deps.append(header[:-1])
    return deps, module_name

class cppm(target):
    """
    A C++ module file, with .cppm suffix.
    This is precompiled to a .pcm file
    Required imported modules are autodetermined
    """
    def __init__(self, pth, *args, **kw):
        super().__init__(*args, **kw)
        pth = pathlib.Path(pth).expanduser()
        pcm = pathlib.Path(self.build) / pth.absolute().relative_to(self.project.absolute()).with_suffix('.pcm')

        name = pth.stem

        self.pcm_dir = pcm.parent
    
        with pth.open("r", encoding="utf-8") as f:
            deps, module_name = scan_file(f, str(pth))
            
        self.update(
            dict(
                deps=[str(pcm)],
                virtual=True
            )
        )
        self.out = str(pcm)

        self.name = module_name
        cppms[module_name] = self

        cppms[str(pcm)] = self.pcm = target(
            name=module_name,
            source=[str(pth)],
            deps=deps,
            out=str(pcm),
            args=[*self.precompile_args, "-o", str(pcm), str(pth), func(self.get_dep_args)]
        )

    def setup(self):
        if not self.pcm_dir.exists():
            self.pcm_dir.mkdir(parents=True)

    def get_dep_pcms(self, linking=False):
        yield f'''-fmodule-file={self.name}={str(self.pcm['out'])}'''
        if linking:
            yield str(self.pcm['out'])
        yield from self.get_dep_args(linking)
        
    def get_dep_args(self, linking=False):
        deps = set()
        for d in self.pcm.deps:
            if d in cppms:
                deps.update(cppms[d].get_dep_pcms(linking))
        yield from sorted(deps)
    @classmethod
    def module(cls, path):
        for f in cppms.values():
            if f.get('source', []) and pathlib.Path(f.get('source')[0]) == (target.project.absolute() / path):
                return f.name
        raise KeyError(f"{path} not found in cppms")

class cpp(target):
    def __init__(self, path, out, *args, **kw):
        super().__init__(*args, **kw)
        pth = pathlib.Path(self.project/path).expanduser()

        self.out = self.build / out
    
        with pth.open("r", encoding="utf-8") as f:
            deps, _ = scan_file(f, None)

        self['deps'] = deps
        self['source'] = [str(pth)]
        self['args'] = self.get('args', []) + ['-o', str(self.out), str(pth), func(self.get_deps)]

    def get_deps(self):
        deps = set()
        for d in self.deps:
            if d in cppms:
                deps.update(cppms[d].get_dep_pcms(linking=True))
        return list(sorted(deps))
                
        
    def setup(self):
        if not self.out.parent.exists():
            self.out.parent.mkdir(parents=True)

            
                        
def find_cppms(*pths: [str | pathlib.Path]) -> None:
    for p in pths:
        pth = pathlib.Path(p).expanduser()
        if not pth.is_dir():
            pth = pth.parent
        for tp, _, files in pth.walk():
            for f in files:
                if f.endswith('.cppm'):
                    cppm(tp/f)


def check(hdr, system=True):
    p = subprocess.Popen(['clang++',
                          '-x',
                          'c++',
                          '-std=c++26',
                          '-stdlib=libc++',
                          '-fimplicit-modules',
                          '-fbuiltin-module-map',
                          '-fimplicit-module-maps',
                          '-',
                          '-E',
                          ],
                         stdin = subprocess.PIPE,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.PIPE)
    if system:
        left = '<'
        right = '>'
    else:
        left = '"'
        right = '"'
    p.stdin.write(f'import {left}{hdr}{right};\n'.encode('utf-8'))
    p.stdin.close()

    p.wait()
    
    if p.poll():
        err = p.stderr.read().decode('utf-8')
        if '(aka ' in err:
            return err.split('(aka ', 1)[1].split(') cannot', 1)[0]

def encode(name):
    return name.replace("/", "_").replace('.', "_")
        
def create_module_file(system = True):
    lines = target.module_lines[:]
    hdrs = system_headers if system else local_headers
    for f in sorted(hdrs):
        print(f"checking {f}");
        p = check(f)
        if p:
            p = p.replace("'", '"')
            lines.append(f"module {encode(f)} {{")
            lines.append(f"    header {p}")
            lines.append(f"    export *")
            lines.append(f"}}")
    return str.join('\n', lines)
            
        

                    
